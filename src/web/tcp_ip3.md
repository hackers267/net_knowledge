{{#title tcp/ip的三次握手和四次挥手}}

# TCP连接的三次握手

![TCP三次握手](./images/tcp-shakes-hands-three-times.webp "TCP三次握手")

建立一个TCP连接需要*三次握手*：

1. __一次握手__: 客户端会随机初始化序号(*client-isn*[^1]),将此序号置于TCP笑意的*序号*字段中，同时把*SYN*[^2]标志位置为*1*，表示*SYN*报文。接着把第一个SYN搱发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于*SYN-SENT*[^3]状态。
2. __二次握手__: 服务端收到客户端的*SYN*报文后，首先服务端也随机初始化自己的序列号(*server-isn*[^4]),将此序号填入TCP首部的*序号*字段中，首次把TCP首部的*确认序列号*字段填入*client_isn + 1*，接着把*SYN*和*ACK*[^5]标志位置为*1*。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处理*SYN-RCVD*[^6]状态。
3. __三次握手__: 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP首部*ACK*标志位置为*1*，其次*确认应答号*字段填入*server_isn + 1*，最后把报文发送给服务端，这次报文可以携带客户端到服务端的数据，之后客户端处于*ESTABLISHED*状态。

经过三次握手的过程，客户端和服务端之间的连接就完成了，接下来进入*ESTABLISHED*状态，服务端和客户端就可以通信了，直到服务端或客户端经过4次挥手关闭连接。

> 注:第三次握手是可以携带数据。

[^1]:*client-isn*是 _client initial sequence number_ 的简写意思为客户端初始化序号。
[^2]:*SYN*是"Synchronize Sequence Numbers"的简写，意思是同步序列号;
[^3]:*SYN-SEND*状态，即同步序列号发布状态;
[^4]:*server-isn*是 _server initial sequence number_ 的简写，意思为服务端初始化序列号。
[^5]:*ACK*即acknowledgement,即确认序列号。
[^6]:*SYN-RCVE*即 _Synchronize Sequence Numbers Received*，即同步序列号已接收。

## 为什么要三次握手？两次不行吗？

- 为了防止服务器开启一些无用的连接增加服务器开销
- 限止已失效的连接请求报文段突然又传送到了服务端，因而产生错误

由于网络传输是有延时的(要通过网络光纤和各种中间代理服务器)，在传输的过程中，比如客户端发起了SYN=1的第一次握手。

如果服务器就直接创建了这个连接并返回包含SYN、ACK和Seq等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直没有接收到服务器返回的数据包。

如果没有第三次握手告诉服务端客户端接收到的服务端传输的数据的话，服务器是不知道客户端有没有接收到服务端返回的信息的。服务端就认为这个连接是可用的，端口就一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接。

这样一来，就会有很多无效的连接端口白白地开着，导致资源的浪费。

其过程如下:

![资源浪费](./images/tcp_error1.webp "资源浪费")

还有一种情况是已经失效的客户端发出的请求信息，由于某种原因传输到了服务器，服务器以为是客户端发出的有效请求，接收后产生错误。

![延迟错误](./images/tcp_error2.webp "延迟错误")

所以我们需要第三次握手来确认这个过程。

通过第三次握手的数据告诉服务端，客户端有没有收到服务端第二次握手时传过到的数据，以及这个连接是不是有效的。若发送的这个数据是*收到且没有问题*的信息，接收后服务器就正常建立TCP连接，否则建立TCP连接失败，服务器关闭连接端口。由此减少服务器开销和接收到失效请求发生的错误。

# 四次挥手

![四次挥手](./images/tcp-waves-four-times.webp "四次挥手")

客户端和服务端都可以主动断开连接，断开连接后主机的*资源*将被释放。

下面讲述客户端主动关闭连接的过程:

1. **一次挥手**: 客户端打算关闭连接，此时会发送一个TCP首部*FIN*[^7]标志位置为*1*的报文，也即*FIN*报文，之后客户端进入*FIN_WAIT_1*状态。
2. **二次挥手**: 服务端收到该报文后，就向客户端发送*ACK*应答报文，接着服务端进入*CLOSED_WAIT*状态。
3. **三次挥手**: 客户端收到服务端的*ACK*应答报文后，之后进入*FIN_WAIT_2*状态。等待服务端处理完数据后，也向客户端发送*FIN*报文，之后服务端进入*LAST_ACK*[^8]状态。
4. **四次挥手**: 客户端收到服务端的*FIN*报文后，回一个*ACK*应答报文，大家好进入*TIME_WATI*状态。服务端收到了*ACK*应答报文后，就进入了*CLOSED*状态，至此服务端已经完成连接的关闭。客户端在经过*2MSL*[^9]一段时间后，自动进入*CLOSED*状态，至此客户端也完成了连接的关闭。

每位方向都需要**一个FIN和一个ACK**，因为通常被称为**四次挥手**。

[^7]: *FIN* 即*Finish*，是完成的意思。
[^8]: *LAST_ACK*即最后确认状态。
[^9]: *MSL*: 即 *Maximum Segment Lifetime*：一段TCP报文在传输过程中的最大生命周期。

## 为什么要挥手4次

回顾一下四次挥手双方发*FIN*包的过程，就能理解为什么需要四次了。

- 关闭连接时，客户端向服务端发送*FIN*时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务器收到客户端的*FIN*报文时，先回一个*ACK*应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送*FIN*报文给客户端来表示同意现在关闭连接。

从上面过程可知，服务端通常需要等待完成的数据的发送和处理，所以服务端的*ACK*和*FIN*一般都会分开发送，从而比三次握手多了一次。

## 为什么客户端在TIME-WAIT阶段要等2MSL

为的是确认服务端是否收到客户端发出的ACK确认报文，当客户端发出最后的ACK确认报文时，并不能确定服务端能够收到该报文。

所以客户端在发送完ACK确认报文之后，会设置一个时长为*2MSL*的计时器。

2MSL即是服务器发出为FIN报文和客户端发出的ACK确认报文所能保持有效的最大时长。

服务器在1MSL内没有收到客户端发出的ACK确认报文，就会再次向客户端发出FIN报文。

  - 如果客户端在2MSL内，再次收到了来自服务器端的FIN报文，说明服务器端由于各种原因没有接收到客户端发出的ACK确认报文。

客户端再次向服务器端发出ACK确认报文，计时器重置，重新开始2MSL的计时。

  - 否则客户端在2MSL内没有再次收到来自服务器端的FIN报文，说明服务器端正常接收了ACK确认报文，客户端可以进入CLOSEDD阶段，完成*四次挥手*。

  所以，客户端要经历时长为2MSL的TIME-WAIT阶段；这也是为什么客户端比服务器端晚进入CLOSED阶段的原因。
